/// Main library module for building the pool-based model.
use std::env;

extern crate clap;

extern crate chrono;

extern crate rust_htslib;
use rust_htslib::bcf::{self, Read};

extern crate shlex;

#[macro_use]
extern crate error_chain;

#[macro_use]
extern crate slog;
use slog::Logger;

extern crate lib_shared;
use lib_shared::bcf_utils;
use lib_shared::regions::GenomeRegions;
use lib_shared::stats::Stats;

mod options;
pub use options::*;

/// This crate's error-related code, generated by `error-chain`.
mod errors {
    // Create the Error, ErrorKind, ResultExt, and Result types
    error_chain!{}
}

pub use errors::*;

/// Build header for the output BCF file.
///
/// This defines all values used throughout the whole window/target specific BAM files,
/// regardless whether they are actually used in the file.
///
/// Note that we use shared FORMAT tags for coverage and fragment count, such that we get
/// unified processing of copy number data in BCF files.
fn build_header(contigs: &GenomeRegions) -> bcf::Header {
    let mut header = bcf::Header::new();

    // Put overall meta information into the BCF header.
    let now = chrono::Utc::now();
    header.push_record(format!("##fileDate={}", now.format("%Y%m%d").to_string()).as_bytes());

    // Put creating tool version and call into file.
    header.push_record(format!("##cnvetti_cmdBuildModelPoolVersion={}", "0.2.0").as_bytes());
    header.push_record(
        format!(
            "##cnvetti_cmdBuildModelPoolCommand={}",
            env::args()
                .map(|s| shlex::quote(&s).to_string())
                .collect::<Vec<String>>()
                .join(" ")
        ).as_bytes(),
    );

    // Note: no samples

    // Put contig information into BCF header.
    for (name, _, length) in &contigs.regions {
        header.push_record(format!("##contig=<ID={},length={}>", name, length).as_bytes());
    }

    // Push the relevant header records.
    let lines = vec![
        // Define ALT column <TARGET>
        "##ALT=<ID=TARGET,Description=\"Record describes a target for fragment counting\">",
        // INFO fields describing the window
        "##INFO=<ID=END,Number=1,Type=Integer,Description=\"Window end\">",
        "##INFO=<ID=CV_IQR,Number=.,Type=Float,Description=\"IQR of normalized coverage.\">",
        "##INFO=<ID=CV_MEDIAN,Number=.,Type=Float,Description=\"IQR of normalized coverage.\">",
        "##INFO=<ID=CV_5SUMMARY,Number=5,Type=Float,Description=\"Five-number summary of \
         the coverage distribution (min, q1, median, q3, max).\">",
        "##INFO=<ID=CV_MEAN,Number=.,Type=Float,Description=\"IQR of normalized coverage.\">",
        "##INFO=<ID=CV_STD_DEV,Number=.,Type=Float,Description=\"Standard deviation of \
         normalized coverage.\">",
        // FILTER fields
        "##FILTER=<ID=HIGH_IQR,Description=\"Normalized coverage IQR is too large.\">",
        "##FILTER=<ID=UNRELIABLE,Description=\"Target is masked because it was called in
         too many reference panel samples.\">",
    ];
    for line in lines {
        header.push_record(line.as_bytes());
    }

    header
}

/// Build bcf::Writer with appropriate header.
fn build_bcf_writer(path: &String, ref_contigs: &GenomeRegions) -> Result<bcf::Writer> {
    let uncompressed = !path.ends_with(".bcf") && !path.ends_with(".vcf.gz");
    let vcf = path.ends_with(".vcf") || path.ends_with(".vcf.gz");

    let header = build_header(ref_contigs);
    bcf::Writer::from_path(&path, &header, uncompressed, vcf)
        .chain_err(|| "Could not open BCF file for writing")
}

fn write_output(
    logger: &mut Logger,
    reader: &mut bcf::Reader,
    options: &BuildModelPoolOptions,
) -> Result<()> {
    // Actually collect the reliable regions and flag for reliability.
    info!(logger, "Writing output BCF file...");
    {
        let contigs = bcf_utils::extract_chroms(&reader.header());
        let mut writer = build_bcf_writer(&options.output, &contigs)
            .chain_err(|| "Could not open output BCF file for writing")?;

        let mut rec_in = reader.empty_record();
        loop {
            match reader.read(&mut rec_in) {
                Ok(_) => (),
                Err(bcf::ReadError::NoMoreRecord) => break,
                _ => bail!("Error reading BCF record"),
            }

            let mut rec_out = writer.empty_record();

            rec_out.set_rid(&rec_in.rid());
            rec_out.set_pos(rec_in.pos() as i32);
            rec_out
                .set_id(&rec_in.id())
                .chain_err(|| "Problem writing ID")?;

            let alleles_v = vec![Vec::from("N"), Vec::from("<TARGET>")];
            let alleles = alleles_v
                .iter()
                .map(|x| x.as_slice())
                .collect::<Vec<&[u8]>>();
            rec_out
                .set_alleles(&alleles)
                .chain_err(|| "Could not update alleles")?;

            let end = rec_in.info(b"END").integer().unwrap().unwrap()[0];
            rec_out
                .push_info_integer(b"END", &[end])
                .chain_err(|| "Could not write INFO/END")?;

            let mut vec_cvs: Vec<f64> = Vec::new();
            for xs in rec_in
                .format(b"CV")
                .float()
                .chain_err(|| "Problem retrieving FORMAT/CV")?
            {
                for x in xs {
                    vec_cvs.push(*x as f64);
                }
            }
            let cvs = vec_cvs.as_slice();

            let q0 = cvs.min();
            let (q1, q2, q3) = cvs.quartiles();
            let q4 = cvs.max();

            rec_out
                .push_info_float(b"CV_IQR", &[(q3 - q1) as f32])
                .chain_err(|| "Problem setting FORMAT/CV_IQR")?;
            rec_out
                .push_info_float(b"CV_MEDIAN", &[q2 as f32])
                .chain_err(|| "Problem setting FORMAT/CV_MEDIAN")?;
            rec_out
                .push_info_float(
                    b"CV_5SUMMARY",
                    &[q0 as f32, q1 as f32, q2 as f32, q3 as f32, q4 as f32],
                )
                .chain_err(|| "Problem setting FORMAT/CV_5SUMMARY")?;
            rec_out
                .push_info_float(b"CV_MEAN", &[cvs.mean() as f32])
                .chain_err(|| "Problem setting FORMAT/CV_MEAN")?;
            rec_out
                .push_info_float(b"CV_STD_DEV", &[cvs.std_dev() as f32])
                .chain_err(|| "Problem setting FORMAT/CV_STD_DEV")?;

            writer
                .write(&rec_out)
                .chain_err(|| "Could not write record")?;
        }
    }

    Ok(())
}

/// Main entry point for the "cmd build-model-pool" command.
pub fn run(logger: &mut Logger, options: &BuildModelPoolOptions) -> Result<()> {
    info!(logger, "Running: cnvetti cmd build-model-pool");
    info!(logger, "Options: {:?}", options);

    // Open input file for reading.
    let mut reader = bcf::Reader::from_path(&options.input)
        .chain_err(|| format!("Could not open input BCF file {}", &options.input))?;

    // Build the model.
    write_output(logger, &mut reader, options)?;

    // Finally, create index on created output file.
    info!(logger, "Building index for output file...");
    bcf_utils::build_index(logger, &options.output).chain_err(|| "Could not build index")?;
    info!(logger, "All done. Have a nice day!");

    Ok(())
}
