/// Main library module for merging coverage files.
use std::env;

extern crate clap;

extern crate chrono;

#[macro_use]
extern crate error_chain;

/// This crate's error-related code, generated by `error-chain`.
mod errors {
    // Create the Error, ErrorKind, ResultExt, and Result types
    error_chain!{}
}

pub use errors::*;

extern crate shlex;

#[macro_use]
extern crate slog;
use slog::Logger;

extern crate rust_htslib;
use rust_htslib::bcf;
use rust_htslib::bcf::record::Numeric;
use rust_htslib::bcf::Read;

extern crate lib_shared;
use lib_shared::bcf_utils;

mod options;
pub use options::*;

/// Main entry point for the "cmd build-model-wis" command.
pub fn run(logger: &mut Logger, options: &RatioOptions) -> Result<()> {
    info!(logger, "Running: cnvetti cmd ratio");
    info!(logger, "Options: {:?}", options);

    debug!(logger, "Opening input file...");
    let mut reader = bcf::Reader::from_path(&options.input)
        .chain_err(|| format!("Could not open BCF file: {}", options.input))?;
    if options.io_threads > 0 {
        reader
            .set_threads(options.io_threads as usize)
            .chain_err(|| "Could not set threads to BCF reader")?;
    }
    let idx_numerator = *reader
        .header()
        .sample_to_id(&options.numerator_sample.clone().into_bytes())
        .chain_err(|| "Numerator sample not found")? as usize;
    let idx_denominator = *reader
        .header()
        .sample_to_id(&options.denominator_sample.clone().into_bytes())
        .chain_err(|| "Numerator sample not found")? as usize;

    {
        debug!(logger, "Opening output file...");
        let mut writer = {
            // Construct extended header (limited to tumor sample).
            let sample = options.numerator_sample.clone().into_bytes();
            let samples: Vec<&[u8]> = vec![&sample];
            let mut header = bcf::Header::from_template_subset(reader.header(), &samples)
                .chain_err(|| "Could not create output header")?;
            // TODO: version should come from one central place
            header.push_record(format!("##cnvetti_cmdRatioVersion={}", "0.1.0").as_bytes());
            header.push_record(
                format!(
                    "##cnvetti_wiseRatioCommand={}",
                    env::args()
                        .map(|s| shlex::quote(&s).to_string())
                        .collect::<Vec<String>>()
                        .join(" ")
                ).as_bytes(),
            );

            let uncompressed =
                !options.output.ends_with(".bcf") && !options.output.ends_with(".vcf.gz");
            let vcf = options.output.ends_with(".vcf") || options.output.ends_with(".vcf.gz");

            bcf::Writer::from_path(options.output.clone(), &header, uncompressed, vcf)
                .chain_err(|| format!("Could not open output BCF file {}", options.output))?
        };

        let mut record = reader.empty_record();
        loop {
            match reader.read(&mut record) {
                Ok(_) => record.unpack(),
                Err(bcf::ReadError::NoMoreRecord) => break,
                _ => bail!("Problem reading BCF record"),
            }

            let (numerator, denominator) = {
                let cvs = record
                    .format(b"CV")
                    .float()
                    .chain_err(|| "Could not access FORMAT/CV")?;
                (cvs[idx_numerator][0] as f64, cvs[idx_denominator][0] as f64)
            };

            let ratio = numerator / denominator;
            let ratio2 = ratio.log2();

            writer.translate(&mut record);
            writer.subset(&mut record);

            if ratio.is_finite() {
                record.push_format_float(b"CV", &[ratio as f32])
            } else {
                record.push_format_float(b"CV", &[f32::missing()])
            }.chain_err(|| "Could not write FORMAT/CV")?;
            if ratio2.is_finite() {
                record.push_format_float(b"CV2", &[ratio2 as f32])
            } else {
                record.push_format_float(b"CV2", &[f32::missing()])
            }.chain_err(|| "Could not write FORMAT/CV2")?;

            writer
                .write(&record)
                .chain_err(|| "Problem writing BCF record to file")?;
        }
    }

    // Finally, create index on created output file.
    info!(logger, "Building index for output file...");
    bcf_utils::build_index(logger, &options.output).chain_err(|| "Could not build index")?;
    info!(logger, "All done. Have a nice day!");

    Ok(())
}
