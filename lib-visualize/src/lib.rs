/// Main library module for the visualization facilities in CNVetti.
use std::fs::File;
use std::io::Write;

extern crate clap;

extern crate rust_htslib;
use rust_htslib::bcf::{self, Read};

#[macro_use]
extern crate slog;
use slog::Logger;

#[macro_use]
extern crate error_chain;

/// This crate's error-related code, generated by `error-chain`.
mod errors {
    // Create the Error, ErrorKind, ResultExt, and Result types
    error_chain!{}
}

pub use errors::*;

mod options;
pub use options::*;

/// This module contains the code for conversion from coverage BCF files to IGV coverage files.
///
/// These, in turn, can be converted to TGV format using `igvtools totdf FILE GENOME`.
pub mod cov_to_igv {

    use super::*;

    /// Write header to file for relative coverage (linear).
    fn write_cov_header(header: &bcf::header::HeaderView, f: &mut File) -> Result<()> {
        f.write_all(
            "#track \
             color=000,000,000 \
             graphType=points \
             viewLimits=0:2.0 \
             midRange=1:1 \
             windowingFunction=mean\n"
                .as_bytes(),
        ).chain_err(|| "Problem writing header")?;
        f.write_all(
            format!(
                "Chromosome\tStart\tEnd\tFeature\t{}\n",
                header
                    .samples()
                    .iter()
                    .map(|x| String::from_utf8(x.to_vec()).expect("Convertion from UTF-8 failed"))
                    .collect::<Vec<String>>()
                    .join("\t")
            ).as_bytes(),
        ).chain_err(|| "Could not write header")?;
        Ok(())
    }

    /// Write header to file for log2-scaled coverage.
    fn write_cov2_header(header: &bcf::header::HeaderView, f: &mut File) -> Result<()> {
        f.write_all(
            "#track \
             color=255,000,000 \
             altColor=000,000,255 \
             graphType=points \
             viewLimits=-1.5:1.5 \
             windowingFunction=mean\n"
                .as_bytes(),
        ).chain_err(|| "Problem writing header")?;
        f.write_all(
            format!(
                "Chromosome\tStart\tEnd\tFeature\t{}\n",
                header
                    .samples()
                    .iter()
                    .map(|x| String::from_utf8(x.to_vec()).expect("Convertion from UTF-8 failed"))
                    .collect::<Vec<String>>()
                    .join("\t")
            ).as_bytes(),
        ).chain_err(|| "Could not write header")?;
        Ok(())
    }

    /// Write header to file for coverage Z-score.
    fn write_covz_header(header: &bcf::header::HeaderView, f: &mut File) -> Result<()> {
        f.write_all(
            "#track \
             color=255,000,000 \
             altColor=000,000,255 \
             graphType=points \
             viewLimits=-3:3 \
             windowingFunction=mean\n"
                .as_bytes(),
        ).chain_err(|| "Problem writing header")?;
        f.write_all(
            format!(
                "Chromosome\tStart\tEnd\tFeature\t{}\n",
                header
                    .samples()
                    .iter()
                    .map(|x| String::from_utf8(x.to_vec()).expect("Convertion from UTF-8 failed"))
                    .collect::<Vec<String>>()
                    .join("\t")
            ).as_bytes(),
        ).chain_err(|| "Could not write header")?;
        Ok(())
    }

    /// Convert one BCF record to IGV file.
    fn write_line(record: &mut bcf::Record, key: &[u8], file: &mut File) -> Result<()> {
        // TODO: after the fix to mutability in bcf::Record recarding info fix mut
        let values = if let Ok(values) = record.format(key).float() {
            Some(values.iter().map(|x| (**x)[0]).collect::<Vec<f32>>())
        } else {
            None
        };

        if let Some(values) = values {
            let chrom = String::from_utf8(
                record
                    .header()
                    .rid2name(record.rid().expect("record without entry in header"))
                    .to_vec(),
            ).chain_err(|| "Could not decode CHROM from UTF-8")?;
            let pos = record.pos();
            let end = record.info(b"END").integer().unwrap().unwrap()[0];
            let feature = String::from_utf8(record.id().to_vec())
                .chain_err(|| "Could not decode ID from UTF-8")?;
            let values_joint = values
                .iter()
                .map(|x| format!("{}", x))
                .collect::<Vec<String>>()
                .join("\t");
            file.write_all(
                format!(
                    "{}\t{}\t{}\t{}\t{}\n",
                    chrom, pos, end, &feature, &values_joint
                ).as_bytes(),
            ).chain_err(|| "Problem writing record")?;
        }

        Ok(())
    }

    /// Execute the extraction of coverage information from coverage BCF file to IGV coverage file.
    pub fn run(logger: &mut Logger, options: &CovToIgvOptions) -> Result<()> {
        info!(logger, "Running: cnvetti visualize cov-to-igv");
        info!(logger, "Options: {:?}", options);

        let mut reader = bcf::Reader::from_path(&options.input)
            .chain_err(|| format!("Could not open input BCF file {}", options.input))?;

        // Open linear coverage IGV and write header.
        let mut file_linear = if let Some(path) = &options.output_igv_cov {
            info!(logger, "Open (linear) coverage file.");
            let mut file = File::create(&path).chain_err(|| format!("Problem opening {}", path))?;
            write_cov_header(&reader.header(), &mut file)
                .chain_err(|| format!("Problem writing header to {}", path))?;
            Some(file)
        } else {
            info!(logger, "No (linear) coverage file.");
            None
        };

        // Open log2-scaled coverage IGV and write header.
        let mut file_cov2 = if let Some(path) = &options.output_igv_cov2 {
            info!(logger, "Open log2-scaled coverage file.");
            let mut file = File::create(&path).chain_err(|| format!("Problem opening {}", path))?;
            write_cov2_header(&reader.header(), &mut file)
                .chain_err(|| format!("Problem writing header to {}", path))?;
            Some(file)
        } else {
            info!(logger, "No log2-scaled coverage file.");
            None
        };

        // Open coverage Z-score IGV and write header.
        let mut file_covz = if let Some(path) = &options.output_igv_covz {
            info!(logger, "Open coverage Z-score file.");
            let mut file = File::create(&path).chain_err(|| format!("Problem opening {}", path))?;
            write_covz_header(&reader.header(), &mut file)
                .chain_err(|| format!("Problem writing header to {}", path))?;
            Some(file)
        } else {
            info!(logger, "No coverage Z-score file.");
            None
        };

        // Open reader and start writing out.
        info!(logger, "Extracting information from BCF file...");
        let mut record = reader.empty_record();
        loop {
            match reader.read(&mut record) {
                Ok(_) => (),
                Err(bcf::ReadError::NoMoreRecord) => break,
                _ => bail!("Error reading BCF record"),
            }

            if let Some(ref mut file) = file_linear {
                write_line(&mut record, b"CV", file)?;
            }
            if let Some(ref mut file) = file_cov2 {
                write_line(&mut record, b"CV2", file)?;
            }
            if let Some(ref mut file) = file_covz {
                write_line(&mut record, b"CVZ", file)?;
            }
        }
        info!(logger, " => done");

        info!(logger, "All done. Have a nice day!");

        Ok(())
    }

}
