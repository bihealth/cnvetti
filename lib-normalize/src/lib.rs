extern crate chrono;

#[macro_use]
extern crate error_chain;

extern crate clap;

extern crate quantiles;

#[macro_use]
extern crate slog;
use slog::Logger;

extern crate strum;
#[macro_use]
extern crate strum_macros;

extern crate rust_htslib;

extern crate shlex;

extern crate lib_shared;
use lib_shared::bcf_utils;

mod options;
pub use options::*;

mod shared;
mod uncorrected;
use uncorrected::*;
mod correct_binned;
use correct_binned::*;

/// This crate's error-related code, generated by `error-chain`.
mod errors {
    // Create the Error, ErrorKind, ResultExt, and Result types
    error_chain!{}
}

pub use errors::*;

/// Main entry point for the `normalize` command.
pub fn run(logger: &mut Logger, options: &NormalizeOptions) -> Result<()> {
    info!(logger, "Running: cnvetti cmd normalize");
    info!(logger, "Options: {:?}", options);

    // TODO: validate input BCF file.
    // // Check that there is exactly one sample in the input file; we cannot handle
    // // multi-sample files (yet, see: #6).
    // if reader.header().sample_count() != 1 {
    //     bail!(
    //         "Input BCF file must have exactly one sample but had {}",
    //         reader.header().sample_count()
    //     );
    // }

    match options.normalization {
        Normalization::TotalCovSum => run_uncorrected_normalization(logger, options)?,
        Normalization::MedianGcBinned => run_binned_correction(logger, options)?,
    }

    // Finally, create index on created output file.
    info!(logger, "Building index for output file...");
    bcf_utils::build_index(logger, &options.output).chain_err(|| "Could not build index")?;

    Ok(())
}
