//! Implementation of `cnvetti cmd segment`.

extern crate bio;
extern crate chrono;
#[macro_use]
extern crate error_chain;
extern crate statrs;

extern crate clap;

extern crate ordered_float;
extern crate quantiles;

#[macro_use]
extern crate slog;
use slog::Logger;

extern crate strum;
#[macro_use]
extern crate strum_macros;

extern crate rust_htslib;
extern crate rust_segment;
extern crate separator;
extern crate shlex;

extern crate lib_shared;
use lib_shared::bcf_utils;

mod seg_haar;
mod seg_wisexome;
mod seg_xhmm;

mod options;
pub use options::*;

/// This crate's error-related code, generated by `error-chain`.
mod errors {
    // Create the Error, ErrorKind, ResultExt, and Result types
    error_chain!{}
}

pub use errors::*;

/// Main entry point for the `segment` command.
pub fn run(logger: &mut Logger, options: &SegmentOptions) -> Result<()> {
    info!(logger, "Running: cnvetti cmd segment");
    info!(logger, "Options: {:?}", options);

    match options.segmentation {
        Segmentation::HaarSeg => seg_haar::run_segmentation(logger, options)?,
        Segmentation::CircularBinarySegmentation => bail!("Not implemented yet!"),
        Segmentation::GenomeHiddenMarkovModel => bail!("Not implemented yet!"),
        Segmentation::ExomeHiddenMarkovModel => seg_xhmm::run_segmentation(logger, options)?,
        Segmentation::WISExome => seg_wisexome::run_segmentation(logger, options)?,
    }

    // Finally, create index on created output file.
    info!(logger, "Building index for output file...");
    bcf_utils::build_index(logger, &options.output).chain_err(|| "Could not build index")?;
    info!(logger, "All done. Have a nice day!");

    Ok(())
}
