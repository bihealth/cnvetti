use std::cmp;
/// Main library module for merging segmentation files.
use std::collections::BTreeMap;
use std::env;

extern crate clap;

extern crate chrono;

#[macro_use]
extern crate error_chain;

/// This crate's error-related code, generated by `error-chain`.
mod errors {
    // Create the Error, ErrorKind, ResultExt, and Result types
    error_chain!{}
}

pub use errors::*;

extern crate shlex;

#[macro_use]
extern crate slog;
use slog::Logger;

extern crate rust_htslib;
use rust_htslib::bcf;

extern crate lib_shared;
use lib_shared::bcf_utils;

mod options;
pub use options::*;

/// Build BCF writer.
fn build_writer(
    logger: &mut Logger,
    header: &bcf::header::HeaderView,
    options: &MergeSegOptions,
) -> Result<bcf::Writer> {
    debug!(logger, "Opening output file...");

    // Construct extended header.
    let mut header = bcf::Header::from_template_subset(header, &[])
        .chain_err(|| "Problem constructing header from template and no samples")?;
    // TODO: version should come from one central place
    let lines = [
        "##INFO=<ID=IMPRECISE,Number=0,Type=Flag,Description=\"Imprecise structural
         variation\">",
        "##INFO=<ID=SVTYPE,Number=1,Type=String,Description=\"Type of structural variant to \
         write out\">",
        "##INFO=<ID=SVLEN,Number=1,Type=Integer,Description=\"Length of the SV to write out\">",
        "##INFO=<ID=CIPOS,Number=2,Type=Integer,Description=\"Confidence interval around POS for \
         imprecise variants\">",
        "##INFO=<ID=CIEND,Number=2,Type=Integer,Description=\"Confidence interval around END for \
         imprecise variants\">",
        "##INFO=<ID=SEG_OCC,Number=2,Type=Integer,Description=\"The number of samples this
         segment was found in.\">",
    ];
    for line in &lines {
        header.push_record(line.as_bytes());
    }
    header.push_record(format!("##cnvetti_cmdMergeSegVersion={}", "0.1.0").as_bytes());
    header.push_record(
        format!(
            "##cnvetti_cmdMergeSegCommand={}",
            env::args()
                .map(|s| shlex::quote(&s).to_string())
                .collect::<Vec<String>>()
                .join(" ")
        ).as_bytes(),
    );

    let uncompressed = !options.output.ends_with(".bcf") && !options.output.ends_with(".vcf.gz");
    let vcf = options.output.ends_with(".vcf") || options.output.ends_with(".vcf.gz");

    Ok(
        bcf::Writer::from_path(&options.output, &header, uncompressed, vcf)
            .chain_err(|| format!("Could not open output BCF file {}", options.output))?,
    )
}

/// Describe an interval with defined "fuzzyness" around both ends.
#[derive(Clone, Debug)]
struct UnsharpInterval {
    start_min: i32,
    start_max: i32,
    end_min: i32,
    end_max: i32,
}

impl UnsharpInterval {
    fn new(start_min: i32, start_max: i32, end_min: i32, end_max: i32) -> Self {
        UnsharpInterval {
            start_min,
            start_max,
            end_min,
            end_max,
        }
    }

    /// Merge two `UnsharpInterval`s yielding a new one.
    fn merge(&self, other: &Self) -> Self {
        Self::new(
            cmp::min(self.start_min, other.start_min),
            cmp::max(self.start_max, other.start_max),
            cmp::min(self.end_min, other.end_min),
            cmp::max(self.end_max, other.end_max),
        )
    }

    // Return mean start position.
    fn start(&self) -> i32 {
        return (self.start_max + self.start_min) / 2;
    }

    // Return Vec with CI around start position.
    fn cistart(&self) -> Vec<i32> {
        vec![self.start_min - self.start(), self.start_max - self.start()]
    }

    // Return mean end position.
    fn end(&self) -> i32 {
        return (self.end_max + self.end_min) / 2;
    }

    // Return Vec with CI around end position.
    fn ciend(&self) -> Vec<i32> {
        vec![self.end_min - self.end(), self.end_max - self.end()]
    }

    // Return length of interval.
    fn len(&self) -> i32 {
        return self.end() - self.start();
    }
}

/// Merge the segmentation BCF files in `reader` to the writer.
pub fn merge_files(
    logger: &mut Logger,
    reader: &mut bcf::synced::SyncedReader,
    writer: &mut bcf::Writer,
    options: &MergeSegOptions,
) -> Result<()> {
    // Load chromosome names and lengths from BCF header.
    let chroms = bcf_utils::extract_chroms(&reader.header(0));
    for (chrom, start, end) in &chroms.regions {
        debug!(logger, "Fetching region {}:{}-{}", &chrom, start + 1, end);
        let rid = reader
            .header(0)
            .name2rid(chrom.as_bytes())
            .chain_err(|| format!("Could not translate header name {}", chrom))?;
        reader
            .fetch(rid, 0, *end as u32)
            .chain_err(|| format!("Could not fetch chromosome {}/{}", chrom, rid))?;

        // Read all intervals from all files from the current contig.
        let mut intervals = Vec::new();
        let mut written;
        let mut occ = BTreeMap::new();
        let mut out_intervals = BTreeMap::new();
        loop {
            match reader.read_next() {
                Ok(num) => if num == 0 {
                    break;
                },
                Err(bcf::ReadError::NoMoreRecord) => break,
                _ => bail!("Error reading BCF record"),
            }
            // Invariant: `intervals` is sorted by start position.
            for i in 0..reader.reader_count() {
                if !reader.has_line(i) {
                    continue; // skip
                }
                let mut record = reader.record(i).expect("Could not retrieve record");
                let start = record.pos() as i32;
                let end = record
                    .info(b"END")
                    .integer()
                    .expect("Could not access INFO/END")
                    .unwrap()[0] as i32;
                intervals.push(start..end);
                trace!(logger, "range = {:?}", start..end);
            }
        }
        written = vec![false; intervals.len()];
        trace!(logger, "# intervals: {}", intervals.len());

        // Greedily merge intervals.
        for i in 0..intervals.len() {
            let a = &intervals[i];
            let a_len = a.len() as f64;
            if written[i] {
                continue; // skip
            }
            written[i] = true;
            let mut count = 1;
            let mut out_interval = UnsharpInterval::new(a.start, a.start, a.end, a.end);

            for j in (i + 1)..intervals.len() {
                let b = &intervals[j];
                if b.start >= a.end {
                    break; // no more overlap possible
                } else if a.start < b.end && b.start < a.end {
                    // potential overlap
                    let b_len = b.len() as f64;
                    let ovl_len = cmp::min(a.end, b.end) - cmp::max(a.start, b.start);
                    let ovl_len = ovl_len as f64;
                    if ovl_len / a_len > options.reciprocal_overlap
                        && ovl_len / b_len > options.reciprocal_overlap
                    {
                        // found a match
                        out_interval = out_interval
                            .merge(&UnsharpInterval::new(b.start, b.start, b.end, b.end));
                        written[j] = true;
                        count += 1;
                    }
                }
            }

            occ.insert(i, count);
            out_intervals.insert(i, out_interval);
        }
        trace!(logger, "# output intervals: {}", out_intervals.len());

        let mut ordered = out_intervals
            .iter()
            .map(|(idx, itv)| (itv.start(), itv.end(), idx))
            .collect::<Vec<_>>();
        ordered.sort();

        // Write out intervals as sites.
        for (_, _, idx) in ordered {
            let itv = out_intervals.get(idx).unwrap();
            let mut record = writer.empty_record();
            record.set_rid(&Some(rid));
            record
                .set_id(&format!("CNV_{}:{}-{}", chrom, itv.start(), itv.end()).as_bytes())
                .chain_err(|| "Problem assigning ID of record")?;
            record.set_pos(itv.start());

            record
                .push_info_string(b"SVTYPE", &[b"CNV"])
                .chain_err(|| "Problem writing INFO/SVTYPE")?;
            record
                .push_info_flag(b"IMPRECISE")
                .chain_err(|| "Problem writing INFO/IMPRECISE")?;
            record
                .push_info_integer(b"END", &[itv.end()])
                .chain_err(|| "Problem writing INFO/END")?;
            record
                .push_info_integer(b"SVLEN", &[itv.len()])
                .chain_err(|| "Problem writing INFO/SVLEN")?;
            record
                .push_info_integer(b"CIPOS", itv.cistart().as_slice())
                .chain_err(|| "Problem writing INFO/CIPOS")?;
            record
                .push_info_integer(b"CIEND", itv.ciend().as_slice())
                .chain_err(|| "Problem writing INFO/CIEND")?;
            record
                .push_info_integer(b"SEG_OCC", &[*occ.get(idx).unwrap() as i32])
                .chain_err(|| "Problem writing INFO/SEG_OCC")?;

            writer
                .write(&record)
                .chain_err(|| "Problem writing merged segment record")?;
        }
    }

    Ok(())
}

/// Main entry point for the "cmd merge-seg" command.
pub fn run(logger: &mut Logger, options: &MergeSegOptions) -> Result<()> {
    info!(logger, "Running: cnvetti cmd merge-seg");
    info!(logger, "Options: {:?}", options);

    // Open reader.
    info!(logger, "Opening input files...");
    let mut reader =
        bcf::synced::SyncedReader::new().chain_err(|| "Could not allocated synced reader")?;
    reader.set_require_index(true);
    reader.set_pairing(bcf::synced::pairing::EXACT);
    for input in &options.input {
        info!(logger, "- {}", input);
        reader
            .add_reader(&input)
            .chain_err(|| format!("Could not open file {} for reading", input))?;
    }
    info!(logger, "=> done");

    // Open output file; construct writer.
    // TODO: do something fancier than taking just the first header
    {
        let mut writer = build_writer(logger, &reader.header(0), &options)?;
        merge_files(logger, &mut reader, &mut writer, &options)?;
    }

    // Finally, create index on created output file.
    info!(logger, "Building index for output file...");
    bcf_utils::build_index(logger, &options.output).chain_err(|| "Could not build index")?;
    info!(logger, "All done. Have a nice day!");

    Ok(())
}
